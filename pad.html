<!DOCTYPE html>
<!-- vim: ts=4

  THIS IS THE DEBUG VERSION !!!

 note: like is equivalent to a pin (i.e. there is no counting!)
-->
<html>
    <head>
	<meta charset="utf-8">
	<title>Fair Pad Management</title>
	<link rel="stylesheet" href="style.css">

	<script src="js/sha256.js"></script>
	<script src="js/essential.js"></script>
	<script src="js/ipfs.js"></script>
	<script src="js/functions.js"></script>
    </head>

    <body>

	<h3>This is our fairPad</h3>
	load locally from: <input id=local_load.file name=filename type=file>
	<button class=local_load onclick=local_load(event)>local load</button>
	<button id=like onclick=like(event)>like</button>
	<button id=pin onclick=pin(event)>pin</button>
<br>
	<textarea id=pad_content onchange="get_status(event)">
ceci est un texte



	</textarea>
<br>
	save locally to: <input id=local_save.file_path name=localpath type=text value="pad_content.txt" placeholder="file-location-to-be-saved-to">
	<button id=save onclick=local_save(event)>local save</button>
<br>
    load from ipfs: <input id=ipfs_load.hash name=ipfshash type=text value="QmfStezxKk8KXj85mBWCfRNrYZRFeWYKB3yi9CDKjuJ95c" placeholder="ipfs-hash-to-be-loaded-from">
	<button id=load onclick=ipfs_load(event)>ipfs load</button>
<br>
    save to ipfs: <span id=ipfs_save.hash></span>
	<button id=ipfs onclick=ipfs_save(event)>ipfs save</button>
<br><br>
	load from mfs: <input id=file_mfs_path_load name=mfspathload type=text value="/etc/myfile.txt" placeholder="file-to-be-loaded-from-mfs">
	<button id=load onclick=mfs_load(event)>mfs load</button>
<br>
	save to mfs: <input id=file_mfs_path_save name=mfspath type=text value="/etc/myfile.txt" placeholder="mfs-file-location-to-be-saved-to">
	<button id=mfs onclick=mfs_save(event)>mfs save</button>

    </body>
</html>

<script>

/*
const publicKey = 'pinata' 
const pinata_secret_xor_key = 'abc';
const pinata_secret_api_key = pinata_secret_xor_key ^ DH_secret(publicKey);
*/
var KEYPAIR;
get_api_keys('data.json').then(
 keys => { KEYPAIR = keys })


async function like(ev) {
     let [callee, caller] = functionNameJS();
     console.debug(callee+'.input.ev:',ev);
     let hash = await ipfs_save();
     console.debug(callee+'.hash:',hash)
     let json = await ipfsPinAdd(hash)
     console.debug(callee+'.json:',json)
     let button = ev.target
         button.innerHTML = 'liked'
         button.onclick = event => { unlike(event) }; 
 
 }
async function unlike(ev) {
     let [callee, caller] = functionNameJS();
     console.debug(callee+'.input.ev:',ev);
     let textData = document.getElementById('pad_content').value;
     let hash = await ipfsGetContentHash(textData);
     let json = await ipfsPinRm(hash)
     console.debug(callee+'.json:',json)
     let button = ev.target
         button.innerHTML = 'like'
         button.onclick = event => { like(event) }; 
}

async function get_status(ev) {
  let [callee, caller] = functionNameJS();
  let textData = document.getElementById('pad_content').value;
  let hash = await ipfsGetContentHash(textData);
  let span = document.getElementById('ipfs_save.hash')
      span.innerHTML = ''; // <a href=http://127.0.0.1:8080/ipfs/'+hash+'>'+hash+'</a>';
  console.debug(callee+'hash:',hash)
  get_pin_status(hash);
  get_like_status(hash);

}
async function get_like_status(hash) {
     let [callee, caller] = functionNameJS();

     let liked = await getPinStatus(hash);
     console.debug(callee+'.liked:',liked)

     let button = document.getElementById('like')
         if (liked == 'liked' || liked == 'recursive') {
           button.onclick = unlike; 
           console.debug(callee+'.button (liked):',button)
           console.dir(button)
           button.innerHTML = liked.replace('recursive','liked')
         } else {
           button.onclick = event => { like(event) }; 
           console.debug(callee+'.button (unliked):',button)
           button.innerHTML = liked.replace('unpinned','like')
         }
}
async function get_pin_status(hash) {
     let [callee, caller] = functionNameJS();
     console.debug(callee+'.input.hash:',hash);
     let pinned = await getPinataStatus(hash);
     let button = document.getElementById('pin')
         if (pinned == 'pinned') {
           button.onclick = unpin; 
           console.debug(callee+'.button (pinned):',button)
           console.dir(button)
         } else {
           button.onclick = event => { pin(event) }; 
           console.debug(callee+'.button (unpinned):',button)
         }
         button.innerHTML = pinned
}

async function unpin(ev) {
  console.error('TBD')
}


async function pin(ev) {
     let [callee, caller] = functionNameJS();
     console.debug(callee+'.input.ev:',ev);

     let pinata_api_key = KEYPAIR.key;
     let pinata_secret_api_key = KEYPAIR.sec;


     let textData = document.getElementById('pad_content').value;
     let qm = await ipfsGetContentHash(textData);
     console.debug(callee+'.qm:',qm)
     let status = await pinByHash(pinata_api_key,pinata_secret_api_key,qm)
     console.debug(callee+'.status:',status)
     let query = 'ipfs_pin_hash='+status.ipfsHash
     let jobs = await pinJobs(pinata_api_key,pinata_secret_api_key,query)
     console.debug(callee+'.jobs:',jobs)

     let button = ev.target
         button.innerHTML = 'pinned' // gonflÃ© !!!
         button.onclick = event => { unlike(event) }; 
 }



async function get_api_keys(jsonfilename) {
   let [callee, caller] = functionNameJS();
     console.debug(callee+'.input.jsonfilename:',jsonfilename);
   let url = './'+jsonfilename;
   return fetch(url,{ mode: 'cors' })
   .then( resp => {
     console.debug(callee+'.resp.status',resp.status);
     return resp.json()
    })
   .then( json => {
     console.debug(callee+'.json',json);
     return json })
   .catch()
 }

 function DH_secret(pubkey) {
     let [callee, caller] = functionNameJS();
     console.log(callee+'.input.pubkey:',pubkey);
     console.error('TBD');
 }

 async function pinJobs(pinataApiKey, pinataSecretApiKey, queryParams) {
     let [callee, caller] = functionNameJS();
     console.debug(callee+'.input.pinataApiKey:',pinataApiKey);
     console.debug(callee+'.input.pinataSecretApiKey:',pinataSecretApiKey);
     console.debug(callee+'.input.queryParams:',queryParams);
     const url = 'https://api.pinata.cloud/pinning/pinJobs?'+queryParams;
     let headers = {
     'Content-Type': 'application/json',
	 'pinata_api_key': pinataApiKey,
	 'pinata_secret_api_key': pinataSecretApiKey
     };
     return fetch(url,{
       method: 'GET',
       headers: headers,
     } )
	 .then(function (response) {
	     //handle response here
         console.debug(callee+'.response:',response);
         return response.json()
	 })
	 .catch(function (error) {
	     //handle error here
         console.error(callee+'.error:',error);
	 });

    
 }

 async function pinByHash(pinataApiKey, pinataSecretApiKey, hashToPin) {
     let [callee, caller] = functionNameJS();
     console.debug(callee+'.input.pinataApiKey:',pinataApiKey);
     console.debug(callee+'.input.pinataSecretApiKey:',pinataSecretApiKey);
     console.debug(callee+'.input.hashToPin:',hashToPin);

     let tics = getTic();
    
     console.debug(callee+'.tics:',tics);

     
     const url = 'https://api.pinata.cloud/pinning/pinByHash';
     const body = {
	 hashToPin: hashToPin,
	 host_nodes: [
	     // '/ip6/2a02:120b:c3c7:7a40:34d6:1935:cdec:81fa/tcp/4001',
	     // '/ip6/2a02:120b:c3c7:7a40:953d:9b46:ba8:ea2f/tcp/4001'
         '/ip6/2a02:120b:c3c7:7a40:104c:59dc:924f:db7a/tcp/45409' 
	 ],
	 pinataMetadata: {
	     name: 'pad_content',
	     keyvalues: {
		 origin: 'fairpad',
         peerid: peerid,
         tics: tics
	     }
	 }
     };
     let headers = {
     'Content-Type': 'application/json',
	 'pinata_api_key': pinataApiKey,
	 'pinata_secret_api_key': pinataSecretApiKey
     };

     return fetch(url,{
       method: 'POST',
       headers: headers,
       body: JSON.stringify(body)
     } )
	 .then(function (response) {
	     //handle response here
         console.debug(callee+'.response:',response);
         return response.json()
	 })
	 .catch(function (error) {
	     //handle error here
         console.error(callee+'.error:',error);
	 });
 }




async function getPinataStatus(hash) {
   let [callee, caller] = functionNameJS();
   console.debug(callee+'.input.hash:',hash);
   let pinataApiKey = KEYPAIR.key;
   let pinataSecretApiKey = KEYPAIR.sec;
   let url = 'https://api.pinata.cloud/data/pinList?hashContains='+hash;
   let headers = {
      'Content-Type': 'application/json',
      'pinata_api_key': pinataApiKey,
      'pinata_secret_api_key': pinataSecretApiKey
   };
   let status = await fetch(url, { headers: headers})
   .then( resp => { 
      console.debug(callee+'.resp:',resp);
      return resp.json()
    })
   .then( json => {
      console.debug(callee+'.json:',json);
      let status;
      if (json.count > 0) {
         if (typeof(json.rows[0].date_unpinned) != 'undefined') {
           status = 'unpinned';
         } else if (typeof(json.rows[0].date_pinned) != 'undefined') {
           status = 'pinned';
         }
      } else {
        status = 'unpinned';
      }
      return status;
   })
   .catch(console.error)

}

async function local_load(ev) {
   let [callee, caller] = functionNameJS();
   console.debug(callee+'.input.ev:',ev);
   let file = document.getElementById('local_load.file').files[0];
   let pad_content = await readAsText(file);
   console.debug(callee+'.pad_content:',pad_content);
   document.getElementById('pad_content').value = pad_content;
   return pad_content;
 }

 function local_save(ev) {
     let [callee, caller] = functionNameJS();
     console.log(callee+'.input.ev:',ev);

     let file_path = document.getElementById('local_save.file_path').value;
     let textData = document.getElementById('pad_content').value;
     download(textData, file_path, 'text/plain');
 }

async function ipfs_load(ev) {
     let [callee, caller] = functionNameJS();
     console.debug(callee+'.input.ev:',ev);
     let hash = document.getElementById('ipfs_load.hash').value;
     let content = await ipfsGetHashContent(hash)
     document.getElementById('pad_content').value = content;
 }
async function ipfs_save(ev) {
     let [callee, caller] = functionNameJS();
     console.debug(callee+'.input.ev:',ev);
     let textData = document.getElementById('pad_content').value;
     let hash = await ipfsAddBinaryContent(textData);
     let span = document.getElementById('ipfs_save.hash')
         span.innerHTML = '<a href=http://127.0.0.1:8080/ipfs/'+hash+'>'+hash+'</a>';
     console.debug(callee+'.span:',span);
     return hash
 }

 function mfs_save(ev) {
     let [callee, caller] = functionNameJS();
     console.log(callee+'.input.ev:',ev);

     let file_mfs_path_save = document.getElementById('file_mfs_path_save').value;
     console.debug(callee+'.file_mfs_path_save:',file_mfs_path_save);
     
     let pad_content = document.getElementById('pad_content').value;
     console.debug(callee+'.pad_content:',pad_content);
     
     return ipfsWriteText(file_mfs_path_save, pad_content) // v0.6.0 truncate works !!!
	 .then ( hash => {
	     console.log(callee+'.file_mfs_path_save: '+file_mfs_path_save+' updated (hash: '+hash+')')
	 })
	 .catch(err => console.error(err))
 } 
 
 async function mfs_load(ev) {
     let [callee, caller] = functionNameJS();
     console.debug(callee+'.input.ev:',ev);

     let file_mfs_path_load = document.getElementById('file_mfs_path_load').value;
     console.debug(callee+'.file_mfs_path_load:',file_mfs_path_load);

     let content;
     if ( file_mfs_path_load.match(new RegExp('/ip[fn]s/')) ) {
	 content = await getContentofIpfsPath(file_mfs_path_load);
     } else {
	 content = await getContentofMfsPath(file_mfs_path_load);
     }
     console.debug(callee+'.content:',content);

     let ele = document.getElementById('pad_content');
     console.debug(callee+'.ele:',ele);
     ele.value = content;
 }

 function download(content, fileName, contentType) {
     let [callee, caller] = functionNameJS();
     console.log(callee+'.input.content:',content);
     console.log(callee+'.input.fileName:',fileName);
     console.log(callee+'.input.contentType:',contentType);

     var a = document.createElement("a");
     var file = new Blob([content], {type: contentType});
     a.href = URL.createObjectURL(file);
     a.download = fileName;
     a.click();
 }

</script>
