<!DOCTYPE html>

key: <span id=key>...</span>
<br>
<input name=hash size=45 type=text value="" placeholder="hash to submit">
<button id=submit onclick="submit(event)">submit</button>
<span id=record_hash></span>

<h2>Interruption Queue</h2>
<div id=queue>
</div>

<!-- <script src=js/base58.js></script>
-->
<script src=js/essential.js></script>
<script src=js/ipfs.js></script>
<script>
 var gw_port = '8080';
 var IRQ_list = [];
 var anon_peerkey = 'QmAnon';

/*
 Wed Sep  9 16:13:21 CEST 2020
 1) get list of keys (/ipns/QmWEKSXsHjn2uYMcwNu9Y3QXPtFe3h3wju9e2itgEN6yvZ)
 2) store private key on keybase for ipfs to directly use (via softlink to keystore)
 3) write hash to allocated namespace.
*/

var peerid;
//console.log('base58:',base58)

async function main(_) {
 let [callee, caller] = functionNameJS();
 peerid = await Promise.resolve(promisedPeerId);
 let anon_keys_path = '/ipns/QmWEKSXsHjn2uYMcwNu9Y3QXPtFe3h3wju9e2itgEN6yvZ'
     anon_keys_path = '/ipfs/QmP9jeZhMVbkP3upLZUMyFMwQyBSn783jxq81UmqwXhLRD'
 let list = await ipfsLsofPath(anon_keys_path)
 console.debug(callee+'.list.Links:',list.Links)
 IRQ_list = list.Links
 let n = IRQ_list.length;
 console.debug('main.n:',n);

 var id_int = qm2int(peerid);
 console.log('main.id_int:',id_int);
 let i = id_int % n;
 console.debug(callee+'.i:',i);

 let anon_hash_key = IRQ_list[i].Hash
 console.debug(callee+'.anon_hash_key:',anon_hash_key);
 let anon_key = await ipfsGetBinaryByHash(anon_hash_key)
 console.debug('main.anon_key:',anon_key);
 //save_private_key(anon_key,anon_name_key);

 anon_name32_key = IRQ_list[i].Name // key_mfxg63s7gazq
 anon_name_key = decode_base32(IRQ_list[i]['Name'].substr(4))
 anon_peerkey = await ipfsGetKeyByName(anon_name_key)
 console.debug(callee+'.anon_peerkey:',anon_peerkey);

 document.getElementById('key').innerHTML=anon_peerkey

 let IRQ_log
 let htlist = '<ul>'
 for (let key of IRQ_list) {
   console.debug(callee+'.key:',key);
   let name32 = key.Name // key_mfxg63s7gazq
   let name = decode_base32(name32.substr(4))
   let hash_key = key.Hash
   htlist += `<li><a href=http://localhost:${gw_port}/ipns/${hash_key} title=${hash_key}>${name}</a></li>`
   
 }
 htlist += '</ul>'
 document.getElementById('queue').innerHTML=htlist
 for (let key of IRQ_list) {
   let name32 = key.Name // key_mfxg63s7gazq
   let name = decode_base32(name32.substr(4))
   let peerkey = await ipfsGetKeyByName(name)
   let payload = await ipnsGetContentByKey(peerkey)
   key.Peerkey = peerkey
   key.Payload = payload
 }
 console.log(callee+'.IRQ_list:',IRQ_list);
 

}
main();

async function submit(ev) {
    let [callee, caller] = functionNameJS();
 let hash_to_submit = document.getElementsByName('hash')[0].value
    console.debug(callee+'.hash_to_submit:',hash_to_submit);
 let record_hash = await ipfsAddTextContent(hash_to_submit)
    console.debug(callee+'.record_hash:',record_hash);
 ipfsNamePublish(anon_peerkey,record_hash);
 document.getElementById('record_hash').innerHTML = 
   `<a href=http://locahost:${gw_port}/ipfs/${record_hash}>${record_hash}</a>`
 return record_hash
}

const ALPHA58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" // bitcoin all but Il0O
//               0123456789012345678901234567890123
const ALPHA32 = "123456789abcdefghjkmnpqrstuvwxyz"

function save_private_key(data,filename) {
  let blob = new Blob([data],  {type : 'x-application/stream'})
  let url = URL.createObjectURL(blob)
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  link.click();
}
function qm2int(qm) {
    let [callee, caller] = functionNameJS();
    console.debug(callee+'.input.qm:',qm);

    let ui8arr = base58ToBytes(qm,ALPHA58)
    console.debug(callee+'.ui8arr:',ui8arr)
    return ((((((+ui8arr[0])*256)+(+ui8arr[1]))*256)+(+ui8arr[2]))*256)+(+ui8arr[3]);
}

function convertToHex(str) {
    var hex = '';
    for(var i=0;i<str.length;i++) {
        hex += ''+str.charCodeAt(i).toString(16);
    }
    return hex;
}


function decode_base32(str) {
  return 'anon_03' // TODO !!!
}

function decode_base58(str) {
  let ui8arr = base58ToBytes(str,ALPHA58)
  let mh = bytesToString(ui8arr)
  return mh
}

// https://codereview.stackexchange.com/a/3589/75693
function bytesToString(bytes) {
    var chars = [];
    for(var i = 0, n = bytes.length; i < n;) {
        chars.push(((bytes[i++] & 0xff) << 8) | (bytes[i++] & 0xff));
    }
    return String.fromCharCode.apply(null, chars);
}

function base32ToBytes(S,A) {
    console.log('S:',S);
    console.log('A:',A);
    let l = S.length;
    let m = A.length;
    let j = 1;
    for(i in S) {
      c = S[l-1 -i ]
      v = A.indexOf( c );
      if (v < 0) return '';
      w = j
      w *= v
      n += w
      j *= m
    }

}


// https://gist.github.com/diafygi/90a3e80ca1c2793220e5/
function base58ToBytes(
    S,            //Base58 encoded string input
    A             //Base58 characters (i.e. "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz")
) {
    console.log('S:',S);
    console.log('A:',A);
    var d = [],   //the array for storing the stream of decoded bytes
        b = [],   //the result byte array that will be returned
        i,        //the iterator variable for the base58 string
        j,        //the iterator variable for the byte array (d)
        c,        //the carry amount variable that is used to overflow from the current byte to the next byte
        n;        //a temporary placeholder variable for the current byte
    for(i in S) { //loop through each base58 character in the input string
        j = 0,                             //reset the byte iterator
        c = A.indexOf( S[i] );             //set the initial carry amount equal to the current base58 digit
        //console.log('S['+i+']:',S[i]);
        //console.log('c:',c);
        if(c < 0)                          //see if the base58 digit lookup is invalid (-1)
            return undefined;              //if invalid base58 digit, bail out and return undefined
        c || b.length ^ i ? i : b.push(0); //prepend the result array with a zero if the base58 digit is zero and non-zero characters haven't been seen yet (to ensure correct decode length)
        while(j in d || c) {               //start looping through the bytes until there are no more bytes and no carry amount
            n = d[j];                      //set the placeholder for the current byte
            n = n ? n * 58 + c : c;        //shift the current byte 58 units and add the carry amount (or just add the carry amount if this is a new byte)
            c = n >> 8;                    //find the new carry amount (1-byte shift of current byte value)
            d[j] = n % 256;                //reset the current byte to the remainder (the carry amount will pass on the overflow)
            j++                            //iterate to the next byte
        }
    }
    while(j--)               //since the byte array is backwards, loop through it in reverse order
        b.push( d[j] );      //append each byte to the result
    //console.log('b:',b);
    return new Uint8Array(b) //return the final byte array in Uint8Array format
}

</script>
